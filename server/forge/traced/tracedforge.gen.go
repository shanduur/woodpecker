// Code generated by gowrap. DO NOT EDIT.
// template: ../../../templates/opentelemetry.go.tpl
// gowrap: http://github.com/hexdigest/gowrap

package traced

//go:generate gowrap gen -p go.woodpecker-ci.org/woodpecker/v2/server/forge -i Forge -t ../../../templates/opentelemetry.go.tpl -o tracedforge.gen.go -l ""

import (
	"context"
	"net/http"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/trace"
	"go.woodpecker-ci.org/woodpecker/v2/server/forge"
	"go.woodpecker-ci.org/woodpecker/v2/server/forge/types"
	"go.woodpecker-ci.org/woodpecker/v2/server/model"
)

// ForgeWithTracing implements forge.Forge interface instrumented with opentracing spans
type ForgeWithTracing struct {
	forge.Forge
	_instance      string
	_spanDecorator func(span trace.Span, params, results map[string]interface{})
}

// NewForgeWithTracing returns ForgeWithTracing
func NewForgeWithTracing(base forge.Forge, instance string, spanDecorator ...func(span trace.Span, params, results map[string]interface{})) ForgeWithTracing {
	d := ForgeWithTracing{
		Forge:     base,
		_instance: instance,
	}

	if len(spanDecorator) > 0 && spanDecorator[0] != nil {
		d._spanDecorator = spanDecorator[0]
	}

	return d
}

// Activate implements forge.Forge
func (_d ForgeWithTracing) Activate(ctx context.Context, u *model.User, r *model.Repo, link string) (err error) {
	ctx, _span := otel.Tracer(_d._instance).Start(ctx, "forge.Forge.Activate")
	defer func() {
		if _d._spanDecorator != nil {
			_d._spanDecorator(_span, map[string]interface{}{
				"ctx":  ctx,
				"u":    u,
				"r":    r,
				"link": link}, map[string]interface{}{
				"err": err})
		} else if err != nil {
			_span.RecordError(err)
			_span.SetAttributes(
				attribute.String("event", "error"),
				attribute.String("message", err.Error()),
			)
		}

		_span.End()
	}()
	return _d.Forge.Activate(ctx, u, r, link)
}

// Auth implements forge.Forge
func (_d ForgeWithTracing) Auth(ctx context.Context, token string, secret string) (s1 string, err error) {
	ctx, _span := otel.Tracer(_d._instance).Start(ctx, "forge.Forge.Auth")
	defer func() {
		if _d._spanDecorator != nil {
			_d._spanDecorator(_span, map[string]interface{}{
				"ctx":    ctx,
				"token":  token,
				"secret": secret}, map[string]interface{}{
				"s1":  s1,
				"err": err})
		} else if err != nil {
			_span.RecordError(err)
			_span.SetAttributes(
				attribute.String("event", "error"),
				attribute.String("message", err.Error()),
			)
		}

		_span.End()
	}()
	return _d.Forge.Auth(ctx, token, secret)
}

// BranchHead implements forge.Forge
func (_d ForgeWithTracing) BranchHead(ctx context.Context, u *model.User, r *model.Repo, branch string) (cp1 *model.Commit, err error) {
	ctx, _span := otel.Tracer(_d._instance).Start(ctx, "forge.Forge.BranchHead")
	defer func() {
		if _d._spanDecorator != nil {
			_d._spanDecorator(_span, map[string]interface{}{
				"ctx":    ctx,
				"u":      u,
				"r":      r,
				"branch": branch}, map[string]interface{}{
				"cp1": cp1,
				"err": err})
		} else if err != nil {
			_span.RecordError(err)
			_span.SetAttributes(
				attribute.String("event", "error"),
				attribute.String("message", err.Error()),
			)
		}

		_span.End()
	}()
	return _d.Forge.BranchHead(ctx, u, r, branch)
}

// Branches implements forge.Forge
func (_d ForgeWithTracing) Branches(ctx context.Context, u *model.User, r *model.Repo, p *model.ListOptions) (sa1 []string, err error) {
	ctx, _span := otel.Tracer(_d._instance).Start(ctx, "forge.Forge.Branches")
	defer func() {
		if _d._spanDecorator != nil {
			_d._spanDecorator(_span, map[string]interface{}{
				"ctx": ctx,
				"u":   u,
				"r":   r,
				"p":   p}, map[string]interface{}{
				"sa1": sa1,
				"err": err})
		} else if err != nil {
			_span.RecordError(err)
			_span.SetAttributes(
				attribute.String("event", "error"),
				attribute.String("message", err.Error()),
			)
		}

		_span.End()
	}()
	return _d.Forge.Branches(ctx, u, r, p)
}

// Deactivate implements forge.Forge
func (_d ForgeWithTracing) Deactivate(ctx context.Context, u *model.User, r *model.Repo, link string) (err error) {
	ctx, _span := otel.Tracer(_d._instance).Start(ctx, "forge.Forge.Deactivate")
	defer func() {
		if _d._spanDecorator != nil {
			_d._spanDecorator(_span, map[string]interface{}{
				"ctx":  ctx,
				"u":    u,
				"r":    r,
				"link": link}, map[string]interface{}{
				"err": err})
		} else if err != nil {
			_span.RecordError(err)
			_span.SetAttributes(
				attribute.String("event", "error"),
				attribute.String("message", err.Error()),
			)
		}

		_span.End()
	}()
	return _d.Forge.Deactivate(ctx, u, r, link)
}

// Dir implements forge.Forge
func (_d ForgeWithTracing) Dir(ctx context.Context, u *model.User, r *model.Repo, b *model.Pipeline, f string) (fpa1 []*types.FileMeta, err error) {
	ctx, _span := otel.Tracer(_d._instance).Start(ctx, "forge.Forge.Dir")
	defer func() {
		if _d._spanDecorator != nil {
			_d._spanDecorator(_span, map[string]interface{}{
				"ctx": ctx,
				"u":   u,
				"r":   r,
				"b":   b,
				"f":   f}, map[string]interface{}{
				"fpa1": fpa1,
				"err":  err})
		} else if err != nil {
			_span.RecordError(err)
			_span.SetAttributes(
				attribute.String("event", "error"),
				attribute.String("message", err.Error()),
			)
		}

		_span.End()
	}()
	return _d.Forge.Dir(ctx, u, r, b, f)
}

// File implements forge.Forge
func (_d ForgeWithTracing) File(ctx context.Context, u *model.User, r *model.Repo, b *model.Pipeline, f string) (ba1 []byte, err error) {
	ctx, _span := otel.Tracer(_d._instance).Start(ctx, "forge.Forge.File")
	defer func() {
		if _d._spanDecorator != nil {
			_d._spanDecorator(_span, map[string]interface{}{
				"ctx": ctx,
				"u":   u,
				"r":   r,
				"b":   b,
				"f":   f}, map[string]interface{}{
				"ba1": ba1,
				"err": err})
		} else if err != nil {
			_span.RecordError(err)
			_span.SetAttributes(
				attribute.String("event", "error"),
				attribute.String("message", err.Error()),
			)
		}

		_span.End()
	}()
	return _d.Forge.File(ctx, u, r, b, f)
}

// Hook implements forge.Forge
func (_d ForgeWithTracing) Hook(ctx context.Context, r *http.Request) (repo *model.Repo, pipeline *model.Pipeline, err error) {
	ctx, _span := otel.Tracer(_d._instance).Start(ctx, "forge.Forge.Hook")
	defer func() {
		if _d._spanDecorator != nil {
			_d._spanDecorator(_span, map[string]interface{}{
				"ctx": ctx,
				"r":   r}, map[string]interface{}{
				"repo":     repo,
				"pipeline": pipeline,
				"err":      err})
		} else if err != nil {
			_span.RecordError(err)
			_span.SetAttributes(
				attribute.String("event", "error"),
				attribute.String("message", err.Error()),
			)
		}

		_span.End()
	}()
	return _d.Forge.Hook(ctx, r)
}

// Login implements forge.Forge
func (_d ForgeWithTracing) Login(ctx context.Context, r *types.OAuthRequest) (up1 *model.User, s1 string, err error) {
	ctx, _span := otel.Tracer(_d._instance).Start(ctx, "forge.Forge.Login")
	defer func() {
		if _d._spanDecorator != nil {
			_d._spanDecorator(_span, map[string]interface{}{
				"ctx": ctx,
				"r":   r}, map[string]interface{}{
				"up1": up1,
				"s1":  s1,
				"err": err})
		} else if err != nil {
			_span.RecordError(err)
			_span.SetAttributes(
				attribute.String("event", "error"),
				attribute.String("message", err.Error()),
			)
		}

		_span.End()
	}()
	return _d.Forge.Login(ctx, r)
}

// Org implements forge.Forge
func (_d ForgeWithTracing) Org(ctx context.Context, u *model.User, org string) (op1 *model.Org, err error) {
	ctx, _span := otel.Tracer(_d._instance).Start(ctx, "forge.Forge.Org")
	defer func() {
		if _d._spanDecorator != nil {
			_d._spanDecorator(_span, map[string]interface{}{
				"ctx": ctx,
				"u":   u,
				"org": org}, map[string]interface{}{
				"op1": op1,
				"err": err})
		} else if err != nil {
			_span.RecordError(err)
			_span.SetAttributes(
				attribute.String("event", "error"),
				attribute.String("message", err.Error()),
			)
		}

		_span.End()
	}()
	return _d.Forge.Org(ctx, u, org)
}

// OrgMembership implements forge.Forge
func (_d ForgeWithTracing) OrgMembership(ctx context.Context, u *model.User, org string) (op1 *model.OrgPerm, err error) {
	ctx, _span := otel.Tracer(_d._instance).Start(ctx, "forge.Forge.OrgMembership")
	defer func() {
		if _d._spanDecorator != nil {
			_d._spanDecorator(_span, map[string]interface{}{
				"ctx": ctx,
				"u":   u,
				"org": org}, map[string]interface{}{
				"op1": op1,
				"err": err})
		} else if err != nil {
			_span.RecordError(err)
			_span.SetAttributes(
				attribute.String("event", "error"),
				attribute.String("message", err.Error()),
			)
		}

		_span.End()
	}()
	return _d.Forge.OrgMembership(ctx, u, org)
}

// PullRequests implements forge.Forge
func (_d ForgeWithTracing) PullRequests(ctx context.Context, u *model.User, r *model.Repo, p *model.ListOptions) (ppa1 []*model.PullRequest, err error) {
	ctx, _span := otel.Tracer(_d._instance).Start(ctx, "forge.Forge.PullRequests")
	defer func() {
		if _d._spanDecorator != nil {
			_d._spanDecorator(_span, map[string]interface{}{
				"ctx": ctx,
				"u":   u,
				"r":   r,
				"p":   p}, map[string]interface{}{
				"ppa1": ppa1,
				"err":  err})
		} else if err != nil {
			_span.RecordError(err)
			_span.SetAttributes(
				attribute.String("event", "error"),
				attribute.String("message", err.Error()),
			)
		}

		_span.End()
	}()
	return _d.Forge.PullRequests(ctx, u, r, p)
}

// Repo implements forge.Forge
func (_d ForgeWithTracing) Repo(ctx context.Context, u *model.User, remoteID model.ForgeRemoteID, owner string, name string) (rp1 *model.Repo, err error) {
	ctx, _span := otel.Tracer(_d._instance).Start(ctx, "forge.Forge.Repo")
	defer func() {
		if _d._spanDecorator != nil {
			_d._spanDecorator(_span, map[string]interface{}{
				"ctx":      ctx,
				"u":        u,
				"remoteID": remoteID,
				"owner":    owner,
				"name":     name}, map[string]interface{}{
				"rp1": rp1,
				"err": err})
		} else if err != nil {
			_span.RecordError(err)
			_span.SetAttributes(
				attribute.String("event", "error"),
				attribute.String("message", err.Error()),
			)
		}

		_span.End()
	}()
	return _d.Forge.Repo(ctx, u, remoteID, owner, name)
}

// Repos implements forge.Forge
func (_d ForgeWithTracing) Repos(ctx context.Context, u *model.User) (rpa1 []*model.Repo, err error) {
	ctx, _span := otel.Tracer(_d._instance).Start(ctx, "forge.Forge.Repos")
	defer func() {
		if _d._spanDecorator != nil {
			_d._spanDecorator(_span, map[string]interface{}{
				"ctx": ctx,
				"u":   u}, map[string]interface{}{
				"rpa1": rpa1,
				"err":  err})
		} else if err != nil {
			_span.RecordError(err)
			_span.SetAttributes(
				attribute.String("event", "error"),
				attribute.String("message", err.Error()),
			)
		}

		_span.End()
	}()
	return _d.Forge.Repos(ctx, u)
}

// Status implements forge.Forge
func (_d ForgeWithTracing) Status(ctx context.Context, u *model.User, r *model.Repo, b *model.Pipeline, p *model.Workflow) (err error) {
	ctx, _span := otel.Tracer(_d._instance).Start(ctx, "forge.Forge.Status")
	defer func() {
		if _d._spanDecorator != nil {
			_d._spanDecorator(_span, map[string]interface{}{
				"ctx": ctx,
				"u":   u,
				"r":   r,
				"b":   b,
				"p":   p}, map[string]interface{}{
				"err": err})
		} else if err != nil {
			_span.RecordError(err)
			_span.SetAttributes(
				attribute.String("event", "error"),
				attribute.String("message", err.Error()),
			)
		}

		_span.End()
	}()
	return _d.Forge.Status(ctx, u, r, b, p)
}

// Teams implements forge.Forge
func (_d ForgeWithTracing) Teams(ctx context.Context, u *model.User) (tpa1 []*model.Team, err error) {
	ctx, _span := otel.Tracer(_d._instance).Start(ctx, "forge.Forge.Teams")
	defer func() {
		if _d._spanDecorator != nil {
			_d._spanDecorator(_span, map[string]interface{}{
				"ctx": ctx,
				"u":   u}, map[string]interface{}{
				"tpa1": tpa1,
				"err":  err})
		} else if err != nil {
			_span.RecordError(err)
			_span.SetAttributes(
				attribute.String("event", "error"),
				attribute.String("message", err.Error()),
			)
		}

		_span.End()
	}()
	return _d.Forge.Teams(ctx, u)
}
